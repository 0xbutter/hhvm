// Copyright (c) Facebook, Inc. and its affiliates.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the "hack" directory of this source tree.

use std::fmt;

use ocamlrep_derive::IntoOcamlRep;

// Three values packed into one 64-bit integer:
//
//    6         5         4         3         2         1         0
// 3210987654321098765432109876543210987654321098765432109876543210
// X<----------------------------><----------------------><------->
//        beginning of line                 line            column
//
// - (X)    This bit left empty for OCaml's tagged integer representation
//          (1 if int, 0 if pointer). OCaml uses the least significant bit
//          for this rather than the most significant, but conversion code
//          (e.g., code generated by deriving IntoOcamlRep) will shift the
//          value left and set the tag bit for us.
// - (bol)  beginning of line (byte offset from start of file) starts at 0,
//          maximum is 2^30-1 = 1,073,741,823
// - (line) line number starts at 1, maximum is 2^24-1 = 16,777,215
// - (col)  column number starts at 0, maximum is 2^9-1 = 511
//            This is saturating, i.e. every column past 511 has column
//            number 511 (so as not to raise exceptions).
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, IntoOcamlRep)]
pub struct FilePosSmall(u64);

const COLUMN_BITS: u64 = 9;
const LINE_BITS: u64 = 24;
const BOL_BITS: u64 = 30;

#[inline]
const fn mask(bits: u64) -> u64 {
    (1 << bits) - 1
}

#[inline]
const fn mask_by(bits: u64, x: u64) -> u64 {
    x & mask(bits)
}

const MAX_COLUMN: u64 = mask(COLUMN_BITS);
const MAX_LINE: u64 = mask(LINE_BITS);
const MAX_BOL: u64 = mask(BOL_BITS);

const DUMMY: u64 = u64::max_value();

impl FilePosSmall {
    #[inline]
    pub const fn is_dummy(self) -> bool {
        self.0 == DUMMY
    }

    #[inline]
    pub fn beg_of_line(self) -> u64 {
        if self.is_dummy() {
            0
        } else {
            mask_by(BOL_BITS, self.0 >> (LINE_BITS + COLUMN_BITS))
        }
    }

    #[inline]
    pub fn line(self) -> u64 {
        if self.is_dummy() {
            0
        } else {
            mask_by(LINE_BITS, self.0 >> COLUMN_BITS)
        }
    }

    #[inline]
    pub fn column(self) -> u64 {
        if self.is_dummy() {
            DUMMY
        } else {
            mask_by(COLUMN_BITS, self.0)
        }
    }

    #[inline]
    const fn bol_line_col_unchecked(bol: u64, line: u64, col: u64) -> Self {
        FilePosSmall((bol << (COLUMN_BITS + LINE_BITS)) + (line << COLUMN_BITS) + col)
    }

    #[inline]
    fn bol_line_col(bol: u64, line: u64, col: u64) -> Option<Self> {
        if col > MAX_COLUMN || line > MAX_LINE || bol > MAX_BOL {
            None
        } else {
            Some(Self::bol_line_col_unchecked(bol, line, col))
        }
    }

    #[inline]
    pub const fn beg_of_file() -> Self {
        Self::bol_line_col_unchecked(0, 1, 0)
    }

    // constructors

    #[inline]
    pub fn from_line_column_offset(line: u64, column: u64, offset: u64) -> Option<Self> {
        Self::bol_line_col(offset - column, line, column)
    }

    #[inline]
    pub fn from_lnum_bol_cnum(lnum: u64, bol: u64, cnum: u64) -> Option<Self> {
        Self::bol_line_col(bol, lnum, cnum - bol)
    }

    // accessors

    #[inline]
    pub fn offset(self) -> u64 {
        self.beg_of_line() + self.column()
    }

    #[inline]
    pub fn line_beg(self) -> (u64, u64) {
        (self.line(), self.beg_of_line())
    }

    #[inline]
    pub fn line_column(self) -> (u64, u64) {
        (self.line(), self.column())
    }

    #[inline]
    pub fn line_column_beg(self) -> (u64, u64, u64) {
        (self.line(), self.column(), self.beg_of_line())
    }

    #[inline]
    pub fn line_column_offset(self) -> (u64, u64, u64) {
        (self.line(), self.column(), self.offset())
    }

    #[inline]
    pub fn line_beg_offset(self) -> (u64, u64, u64) {
        (self.line(), self.beg_of_line(), self.offset())
    }

    #[inline]
    pub fn with_column(self, col: u64) -> Self {
        match Self::bol_line_col(self.beg_of_line(), self.line(), col) {
            None => FilePosSmall(DUMMY),
            Some(pos) => pos,
        }
    }
}

impl fmt::Debug for FilePosSmall {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        fmt.debug_struct("FilePosSmall")
            .field("bol", &self.beg_of_line())
            .field("line", &self.line())
            .field("column", &self.column())
            .finish()
    }
}
